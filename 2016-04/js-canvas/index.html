<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript,Canvas," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="理解元素&amp;lt;canvas&amp;gt;由几组 API 构成,有基本功能 2D 上下文,以及一个名为WebGL的 3D 上下文
基本用法1.先设置 width 和 height 属性
&amp;lt;canvas id=&amp;quot;drawing&amp;quot; width=&amp;quot; 200&amp;quot; height=&amp;quot;200&amp;quot;&amp;gt;A drawing of something.&amp;lt;">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 使用 Canvas 绘图">
<meta property="og:url" content="http://ringcrl.com/2016-04/js-canvas/index.html">
<meta property="og:site_name" content="RingTalk">
<meta property="og:description" content="理解元素&amp;lt;canvas&amp;gt;由几组 API 构成,有基本功能 2D 上下文,以及一个名为WebGL的 3D 上下文
基本用法1.先设置 width 和 height 属性
&amp;lt;canvas id=&amp;quot;drawing&amp;quot; width=&amp;quot; 200&amp;quot; height=&amp;quot;200&amp;quot;&amp;gt;A drawing of something.&amp;lt;">
<meta property="og:updated_time" content="2016-04-26T08:07:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript 使用 Canvas 绘图">
<meta name="twitter:description" content="理解元素&amp;lt;canvas&amp;gt;由几组 API 构成,有基本功能 2D 上下文,以及一个名为WebGL的 3D 上下文
基本用法1.先设置 width 和 height 属性
&amp;lt;canvas id=&amp;quot;drawing&amp;quot; width=&amp;quot; 200&amp;quot; height=&amp;quot;200&amp;quot;&amp;gt;A drawing of something.&amp;lt;">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> JavaScript 使用 Canvas 绘图 | RingTalk </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7c95bb71fd7c5dd5024a13675c205ea2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">RingTalk</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">最朴实的生活，最遥远的梦想。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'qp8_7pbfcjzMmTzmmaqF','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JavaScript 使用 Canvas 绘图
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-26T00:00:00+08:00" content="2016-04-26">
              2016-04-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016-04/js-canvas/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016-04/js-canvas/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="理解元素"><a href="#理解元素" class="headerlink" title="理解元素"></a>理解<canvas>元素</canvas></h3><p><code>&lt;canvas&gt;</code>由几组 API 构成,有基本功能 2D 上下文,以及一个名为WebGL的 3D 上下文</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>1.先设置 width 和 height 属性</p>
<pre><code>&lt;canvas id=&quot;drawing&quot; width=&quot; 200&quot; height=&quot;200&quot;&gt;A drawing of something.&lt;/canvas&gt;
</code></pre><p>2.要在 canvas 上绘图,需要取得绘图上下文:<br>调用getContext()方法传入上下文名字,传入”2d”,就可以取得2D上下文</p>
<pre><code>var drawing = document.getElementById(&quot;drawing&quot;);
//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){
var context = drawing.getContext(&quot;2d&quot;);
//更多代码
}
</code></pre><p>3.在使用<code>&lt;canvas&gt;</code>元素之前,首先需要检测 getContext() 方法是否存在</p>
<p>4.使用 toDataURL() 方法,可以导出在 <code>&lt;canvas&gt;</code> 元素上绘制的图像,该方法接受一个参数,即图像的 MIME 类型格式,而且适合用于创建图像的任何上下文</p>
<pre><code>var drawing = document.getElementById(&quot;drawing&quot;);
//确定浏览器支持&lt;canvas&gt;元素 if (drawing.getContext){
//取得图像的数据 URI
var imgURI = drawing.toDataURL(&quot;image/png&quot;);
//显示图像
var image = document.createElement(&quot;img&quot;);
image.src = imgURI;
document.body.appendChild(image);
}
</code></pre><h3 id="绘制简单的-2D-图形"><a href="#绘制简单的-2D-图形" class="headerlink" title="绘制简单的 2D 图形"></a>绘制简单的 2D 图形</h3><h4 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h4><p>操作结果取决于两个属性,fillStyle和strokeStyle</p>
<pre><code>var drawing = document.getElementById(&quot;drawing&quot;);
//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){
    var context = drawing.getContext(&quot;2d&quot;);
    context.strokeStyle = &quot;red&quot;;
    context.fillStyle = &quot;#0000ff&quot;;
}
</code></pre><h4 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h4><p>矩形是唯一一种可以在 2D 上下文中绘制的形状<br>与矩形有关的方法包括 fillRect()、 strokeRect()和 clearRect()</p>
<pre><code>var drawing = document.getElementById(&quot;drawing&quot;);
//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){
    var context = drawing.getContext(&quot;2d&quot;);
/*
- 根据 Mozilla 的文档
- http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage */

//绘制红色矩形
context.fillStyle = &quot;#ff0000&quot;;
context.fillRect(10, 10, 50, 50);

//绘制半透明的蓝色矩形
context.fillStyle = &quot;rgba(0,0,255,0.5)&quot;;
context.fillRect(30, 30, 50, 50);
}
</code></pre><p>strokeRect()方法在画布上绘制的矩形会使用指定的颜色描边。描边颜色通过 strokeStyle 属性指定。</p>
<pre><code>var drawing = document.getElementById(&quot;drawing&quot;);

//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){
        var context = drawing.getContext(&quot;2d&quot;);
/*
- 根据 Mozilla 的文档
- http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage 
*/

//绘制红色描边矩形
context.strokeStyle = &quot;#ff0000&quot;;
context.strokeRect(10, 10, 50, 50);

//绘制半透明的蓝色描边矩形
context.strokeStyle = &quot;rgba(0,0,255,0.5)&quot;;
context.strokeRect(30, 30, 50, 50);
}
</code></pre><p>clearRect()方法用于清除画布上的矩形区域</p>
<pre><code>context.clearRect(40, 40, 10, 10);
</code></pre><h4 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h4><p>要绘制路径,首先必须调用 beginPath()方法,表示要开始 绘制新路径</p>
<p>先看代码实例:即绘制一个不带数字的时钟表盘。</p>
<pre><code>var drawing = document.getElementById(&quot;drawing&quot;);

//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){
    var context = drawing.getContext(&quot;2d&quot;);

//开始路径
context.beginPath();

//绘制外圆
context.arc(100, 100, 99, 0, 2 * Math.PI, false);

//绘制内圆
context.moveTo(194, 100);
context.arc(100, 100, 94, 0, 2 * Math.PI, false);

//绘制分针
context.moveTo(100, 100);
context.lineTo(100, 15);

//绘制时针
context.moveTo(100, 100);
context.lineTo(35, 100);

//描边路径
    context.stroke();
}
</code></pre><p>以上使用到的或者没有使用到的API</p>
<blockquote>
<p>arc(x, y, radius, startAngle, endAngle, counterclockwise):以(x,y)为圆心绘 制一条弧线,弧线半径为 radius,起始和结束角度(用弧度表示)分别为 startAngle 和 endAngle。最后一个参数表示 startAngle 和 endAngle 是否按逆时针方向计算,值为 false 表示按顺时针方向计算。</p>
<p>arcTo(x1, y1, x2, y2, radius):从上一点开始绘制一条弧线,到(x2,y2)为止,并且以 给定的半径 radius 穿过(x1,y1)。</p>
<p>bezierCurveTo(c1x, c1y, c2x, c2y, x, y):从上一点开始绘制一条曲线,到(x,y)为 止,并且以(c1x,c1y)和(c2x,c2y)为控制点。</p>
<p>lineTo(x, y):从上一点开始绘制一条直线,到(x,y)为止。</p>
<p>moveTo(x, y):将绘图游标移动到(x,y),不画线。</p>
<p>quadraticCurveTo(cx, cy, x, y):从上一点开始绘制一条二次曲线,到(x,y)为止,并<br>且以(cx,cy)作为控制点。</p>
<p>rect(x, y, width, height):从点(x,y)开始绘制一个矩形,宽度和高度分别由 width 和<br>height 指定。这个方法绘制的是矩形路径,而不是 strokeRect()和 fillRect()所绘制的独<br>立的形状。</p>
</blockquote>
<p>创建了路径后,接下来有几种可能的选择。如果想绘制一条连接到路径起点的线条,可以调用<br>closePath()。如果路径已经完成,你想用 fillStyle 填充它,可以调用 fill()方法。另外,还可 以调用 stroke()方法对路径描边,描边使用的是 strokeStyle。最后还可以调用 clip(),这个方法 可以在路径上创建一个剪切区域。</p>
<p>由于路径的使用很频繁,所以就有了一个名为 isPointInPath()的方法。这个方法接收 x 和 y 坐标作为 参数,用于在路径被关闭之前确定画布上的某一点是否位于路径上:</p>
<pre><code>if (context.isPointInPath(100, 100)){
        alert(&quot;Point (100, 100) is in the path.&quot;);
}
</code></pre><h4 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h4><p>绘制文本主要有两个方法:fillText()和 strokeText(),这两个方法都以下列 3 个属性为基础</p>
<blockquote>
<p>font:表示文本样式、大小及字体,用 CSS 中指定字体的格式来指定,例如”10px Arial”。</p>
<p>textAlign:表示文本对齐方式。可能的值有”start”、”end”、”left”、”right”和”center”。<br>建议使用”start”和”end”,不要使用”left”和”right”,因为前两者的意思更稳妥,能同时适合从左到右和从右到左显示(阅读)的语言。 </p>
<p>textBaseline:表示文本的基线。可能的值有”top”、”hanging”、”middle”、”alphabetic”、<br>“ideographic”和”bottom”。</p>
</blockquote>
<p>例如要在表盘上面绘制数字12:</p>
<pre><code>context.font = &quot;bold 14px Arial&quot;;
context.textAlign = &quot;center&quot;;
context.textBaseline = &quot;middle&quot;;
context.fillText(&quot;12&quot;, 100, 20);
</code></pre><h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><p>通过上下文的变换,可以把处理后的图像绘制到画布上。</p>
<blockquote>
<p>rotate(angle):围绕原点旋转图像 angle 弧度。</p>
<p>scale(scaleX, scaleY):缩放图像,在 x 方向乘以 scaleX,在 y 方向乘以 scaleY。scaleX<br>和 scaleY 的默认值都是 1.0。</p>
<p>translate(x,y):将坐标原点移动到(x,y)。执行这个变换之后,坐标(0,0)会变成之前由(x,y)<br>表示的点。</p>
<p>transform(m1_1, m1_2, m2_1, m2_2, dx, dy):直接修改变换矩阵,方式是乘以如下矩阵。<br>m1_1 m1_2 dx<br>m2_1 m2_2 dy<br>0    0    1  </p>
<p>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy):将变换矩阵重置为默认状态,然后 再调用 transform()。</p>
</blockquote>
<h4 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h4><p>如果你想把一幅图像绘制到画布上,可以使用 drawImage() 方法。根据期望的最终结果不同,调用这个方法时,可以使用三种不同的参数组合。最简单的调用方式 是传入一个 HTML<code>&lt;img&gt;</code>元素,以及绘制该图像的起点的 x 和 y 坐标。</p>
<pre><code>var image = document.images[0];
context.drawImage(image, 10, 10);
</code></pre><p>可以再多传入两个参数分别表示目标宽度和目标高度。通过这种方式来缩放图像并不影响上下文的变换矩阵,绘制出来的图像大小会变成 20×30 像素。</p>
<pre><code>context.drawImage(image, 50, 10, 20, 30);
</code></pre><p>除了给 drawImage()方法传入 HTML<code>&lt;img&gt;</code>元素外,还可以传入另一个<code>&lt;canvas&gt;</code>元素作为其第一 个参数。这样,就可以把另一个画布内容绘制到当前画布上。</p>
<h4 id="绘制阴影"><a href="#绘制阴影" class="headerlink" title="绘制阴影"></a>绘制阴影</h4><p>2D 上下文会根据以下几个属性的值,自动为形状或路径绘制出阴影。<br>只要在绘制前为它们设置适当的值,就能自动产生阴影。例如:</p>
<pre><code>var context = drawing.getContext(&quot;2d&quot;);

//设置阴影
context.shadowOffsetX = 5;
context.shadowOffsetY = 5;
context.shadowBlur = 4;
context.shadowColor = &quot;rgba(0, 0, 0, 0.5)&quot;;

//绘制红色矩形
context.fillStyle = &quot;#ff0000&quot;;
context.fillRect(10, 10, 50, 50);
</code></pre><p>以上例子涉及到的属性值:</p>
<blockquote>
<p>shadowColor:用 CSS 颜色格式表示的阴影颜色,默认为黑色。</p>
<p>shadowOffsetX:形状或路径 x 轴方向的阴影偏移量,默认为 0。</p>
<p>shadowOffsetY:形状或路径 y 轴方向的阴影偏移量,默认为 0。</p>
<p>shadowBlur:模糊的像素数,默认 0,即不模糊。</p>
</blockquote>
<h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><p>渐变由 CanvasGradient 实例表示,很容易通过 2D 上下文来创建和修改。要创建一个新的线性渐变,可以调用 createLinearGradient()方法。</p>
<p>创建了渐变对象后,下一步就是使用 addColorStop()方法来指定色标。这个方法接收两个参数: 色标位置和 CSS 颜色值。色标位置是一个 0(开始的颜色)到 1(结束的颜色)之间的数字。</p>
<pre><code>var gradient = context.createLinearGradient(30, 30, 70, 70);
gradient.addColorStop(0, &quot;white&quot;);
gradient.addColorStop(1, &quot;black&quot;);
</code></pre><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>模式其实就是重复的图像,可以用来填充或描边图形。要创建一个新模式,可以调用 createPattern()方法并传入两个参数:一个 HTML <code>&lt;img&gt;</code>元素和一个表示如何重复图像的字符串。 其中,第二个参数的值与 CSS 的 background-repeat 属性值相同,包括”repeat”、”repeat-x”、 “repeat-y”和”no-repeat”。看一个例子。</p>
<pre><code>var image = document.images[0],
    pattern = context.createPattern(image, &quot;repeat&quot;);
//绘制矩形
context.fillStyle = pattern;
context.fillRect(10, 10, 150, 150);
</code></pre><h4 id="使用图像数据"><a href="#使用图像数据" class="headerlink" title="使用图像数据"></a>使用图像数据</h4><p>2D 上下文的一个明显的长处就是,可以通过 getImageData()取得原始图像数据。<br>例如可以通过此方法将一个图像去色</p>
<h4 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h4><p>还有两个会应用到 2D 上下文中所有绘制操作的属性:globalAlpha 和 globalComposition- Operation。其中,globalAlpha 是一个介于 0 和 1 之间的值(包括 0 和 1),用于指定所有绘制的透 明度。默认值为 0。如果所有后续操作都要基于相同的透明度,就可以先把 globalAlpha 设置为适当 值,然后绘制,最后再把它设置回默认值 0。下面来看一个例子。</p>
<pre><code>//绘制红色矩形
context.fillStyle = &quot;#ff0000&quot;;
context.fillRect(10, 10, 50, 50);

//修改全局透明度
context.globalAlpha = 0.5;

//绘制蓝色矩形
context.fillStyle = &quot;rgba(0,0,255,1)&quot;;
context.fillRect(30, 30, 50, 50);

//重置全局透明度
context.globalAlpha = 0;
</code></pre><p>第二个属性 globalCompositionOperation 表示后绘制的图形怎样与先绘制的图形结合。这个 属性的值是字符串,可能的值如下。</p>
<blockquote>
<p>source-over(默认值):后绘制的图形位于先绘制的图形上方。<br>source-in:后绘制的图形与先绘制的图形重叠的部分可见,两者其他部分完全透明。<br>source-out:后绘制的图形与先绘制的图形不重叠的部分可见,先绘制的图形完全透明。<br>source-atop:后绘制的图形与先绘制的图形重叠的部分可见,先绘制图形不受影响。<br>destination-over:后绘制的图形位于先绘制的图形下方,只有之前透明像素下的部分才可见。<br>destination-in:后绘制的图形位于先绘制的图形下方,两者不重叠的部分完全透明。<br>destination-out:后绘制的图形擦除与先绘制的图形重叠的部分。<br>destination-atop:后绘制的图形位于先绘制的图形下方,在两者不重叠的地方,先绘制的图形会变透明。<br>lighter:后绘制的图形与先绘制的图形重叠部分的值相加,使该部分变亮。<br>copy:后绘制的图形完全替代与之重叠的先绘制图形。<br>xor:后绘制的图形与先绘制的图形重叠的部分执行“异或”操作。</p>
<h3 id="使用WebGL绘制-3D-图形"><a href="#使用WebGL绘制-3D-图形" class="headerlink" title="使用WebGL绘制 3D 图形"></a>使用WebGL绘制 3D 图形</h3></blockquote>
<p>要全面了解 OpenGL,请访问 www.opengl.org。<br>要全面学习 WebGL,请参考 www.learningwebgl.com,其 中包含非常棒的系列教程。</p>
<p>以下内容在高程P463,这里只列出大纲,让读者知道WebGL大概能干嘛,具体实现方法请翻看手册.</p>
<p><strong>类型化数组</strong><br>WebGL 涉及的复杂计算需要提前知道数值的精度,而标准的 JavaScript 数值无法满足需要。为此,WebGL 引入了一个概念,叫类型化数组(typed arrays)。类型化数组也是数组,只不过其元素被设置为 特定类型的值。<br>类型化数组的核心就是一个名为 ArrayBuffer 的类型。每个 ArrayBuffer 对象表示的只是内存 中指定的字节数,但不会指定这些字节用于保存什么类型的数据。通过 ArrayBuffer 所能做的,就是 为了将来使用而分配一定数量的字节。例如,下面这行代码会在内存中分配 20B。</p>
<pre><code>var buffer = new ArrayBuffer(20);
</code></pre><p>创建了 ArrayBuffer 对象后,能够通过该对象获得的信息只有它包含的字节数,方法是访问其<br>byteLength 属性:</p>
<pre><code>var bytes = buffer.byteLength;
</code></pre><p><strong>视图</strong><br>使用 ArrayBuffer(数组缓冲器类型)的一种特别的方式就是用它来创建数组缓冲器视图。</p>
<p><strong>类型化视图</strong><br>类型化视图一般也被称为类型化数组,因为它们除了元素必须是某种特定的数据类型外,与常规的数组无异。</p>
<p><strong>WebGL上下文</strong></p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>如果你熟悉 OpenGL,那肯定会对各种操作中使用非常多的常量印象深刻。这些常量在 OpenGL 中 都带前缀 <code>GL_</code>。在 WebGL 中,保存在上下文对象中的这些常量都没有<code>GL_</code>前缀。比如说,<code>GL_COLOR_BUFFER_BIT</code>常量在 WebGL 上下文中就是<code>gl.COLOR_BUFFER_BIT</code>。WebGL 以这种方式支 持大多数 OpenGL 常量(有一部分常量是不支持的)。</p>
<h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>OpenGL(以及 WebGL)中的很多方法都试图通过名字传达有关数据类型的信息。</p>
<h4 id="准备绘图"><a href="#准备绘图" class="headerlink" title="准备绘图"></a>准备绘图</h4><p>在实际操作 WebGL 上下文之前,一般都要使用某种实色清除<code>&lt;canvas&gt;</code>,为绘图做好准备。为此, 首先必须使用 clearColor()方法来指定要使用的颜色值</p>
<h4 id="视口与坐标"><a href="#视口与坐标" class="headerlink" title="视口与坐标"></a>视口与坐标</h4><p>开始绘图之前,通常要先定义 WebGL 的视口(viewport)。默认情况下,视口可以使用整个<code>&lt;canvas&gt;</code> 区域。要改变视口大小,可以调用 viewport()方法并传入 4 个参数</p>
<h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>顶点信息保存在 JavaScript 的类型化数组中,使用之前必须转换到 WebGL 的缓冲区。</p>
<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>JavaScript 与 WebGL 之间的一个最大的区别在于,WebGL 操作一般不会抛出错误。为了知道是否 7 有错误发生,必须在调用某个可能出错的方法后,手工调用 gl.getError()方法。这个方法返回一个 表示错误类型的常量。</p>
<h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><p>着色器(shader)是 OpenGL 中的另一个概念。WebGL 中有两种着色器:顶点着色器和片段(或像<br> 素)着色器。顶点着色器用于将 3D 顶点转换为需要渲染的 2D 点。片段着色器用于准确计算要绘制的每个像素的颜色。</p>
<h4 id="编写着色器"><a href="#编写着色器" class="headerlink" title="编写着色器"></a>编写着色器</h4><p>GLSL 是一种类 C 语言,专门用于编写 OpenGL 着色器。</p>
<h4 id="编写着色器程序"><a href="#编写着色器程序" class="headerlink" title="编写着色器程序"></a>编写着色器程序</h4><p>浏览器不能理解 GLSL 程序,因此必须准备好字符串形式的 GLSL 程序,以便编译并链接到着色器 程序。</p>
<h4 id="为着色器传入值"><a href="#为着色器传入值" class="headerlink" title="为着色器传入值"></a>为着色器传入值</h4><p>前面定义的着色器都必须接收一个值才能工作。为了给着色器传入这个值,必须先找到要接收这个<br>值的变量。</p>
<h4 id="调试着色器和程序"><a href="#调试着色器和程序" class="headerlink" title="调试着色器和程序"></a>调试着色器和程序</h4><p>与 WebGL 中的其他操作一样,着色器操作也可能会失败,而且也是静默失败。如果你想知道着色 器或程序执行中是否发生了错误,必须亲自询问 WebGL 上下文。</p>
<h4 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h4><p>WebGL 只能绘制三种形状:点、线和三角。其他所有形状都是由这三种基本形状合成之后,再绘 制到三维空间中的。</p>
<h4 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h4><p>WebGL 的纹理可以使用 DOM 中的图像。</p>
<h4 id="读取像素"><a href="#读取像素" class="headerlink" title="读取像素"></a>读取像素</h4><p>与 2D 上下文 类似,通过 WebGL 上下文也能读取像素值。读取像素值的方法 readPixels()与 OpenGL 中的同名方法只有一点不同,即最后一个参数必须是类型化数组。</p>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag">#JavaScript</a>
          
            <a href="/tags/Canvas/" rel="tag">#Canvas</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016-04/programme/" rel="next" title="JavaScript 50道经典编程题">
                <i class="fa fa-chevron-left"></i> JavaScript 50道经典编程题
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016-04/FE-interview/" rel="prev" title="大前端面试题">
                大前端面试题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016-04/js-canvas/"
           data-title="JavaScript 使用 Canvas 绘图" data-url="http://ringcrl.com/2016-04/js-canvas/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/RingTalk.jpg"
               alt="Chenng" />
          <p class="site-author-name" itemprop="name">Chenng</p>
          <p class="site-description motion-element" itemprop="description">前端手艺人</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ringcrl" target="_blank" title="GitHub">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/ringcrl" target="_blank" title="Weibo">
                  
                    <i class="fa fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解元素"><span class="nav-number">1.</span> <span class="nav-text">理解元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本用法"><span class="nav-number">1.1.</span> <span class="nav-text">基本用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绘制简单的-2D-图形"><span class="nav-number">2.</span> <span class="nav-text">绘制简单的 2D 图形</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#填充和描边"><span class="nav-number">2.1.</span> <span class="nav-text">填充和描边</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绘制矩形"><span class="nav-number">2.2.</span> <span class="nav-text">绘制矩形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绘制路径"><span class="nav-number">2.3.</span> <span class="nav-text">绘制路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绘制文本"><span class="nav-number">2.4.</span> <span class="nav-text">绘制文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变换"><span class="nav-number">2.5.</span> <span class="nav-text">变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绘制图像"><span class="nav-number">2.6.</span> <span class="nav-text">绘制图像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绘制阴影"><span class="nav-number">2.7.</span> <span class="nav-text">绘制阴影</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#渐变"><span class="nav-number">2.8.</span> <span class="nav-text">渐变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式"><span class="nav-number">2.9.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用图像数据"><span class="nav-number">2.10.</span> <span class="nav-text">使用图像数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合成"><span class="nav-number">2.11.</span> <span class="nav-text">合成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用WebGL绘制-3D-图形"><span class="nav-number">3.</span> <span class="nav-text">使用WebGL绘制 3D 图形</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常量"><span class="nav-number">3.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法命名"><span class="nav-number">3.2.</span> <span class="nav-text">方法命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#准备绘图"><span class="nav-number">3.3.</span> <span class="nav-text">准备绘图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#视口与坐标"><span class="nav-number">3.4.</span> <span class="nav-text">视口与坐标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲区"><span class="nav-number">3.5.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误"><span class="nav-number">3.6.</span> <span class="nav-text">错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#着色器"><span class="nav-number">3.7.</span> <span class="nav-text">着色器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编写着色器"><span class="nav-number">3.8.</span> <span class="nav-text">编写着色器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编写着色器程序"><span class="nav-number">3.9.</span> <span class="nav-text">编写着色器程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为着色器传入值"><span class="nav-number">3.10.</span> <span class="nav-text">为着色器传入值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调试着色器和程序"><span class="nav-number">3.11.</span> <span class="nav-text">调试着色器和程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绘图"><span class="nav-number">3.12.</span> <span class="nav-text">绘图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#纹理"><span class="nav-number">3.13.</span> <span class="nav-text">纹理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取像素"><span class="nav-number">3.14.</span> <span class="nav-text">读取像素</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <a style="text-decoration:none;" href="https://github.com/ringcrl" target="_blank">GitHub</a>
<span>&</span>
<a style="text-decoration:none;" href="http://weibo.com/ringcrl" target="_blank">Weibo</a>

<div class="copyright" >
  
  &copy;
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenng</span>
</div>
        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ringtalk"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
