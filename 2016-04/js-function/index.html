<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript,函数,this,arguments,闭包,作用域," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="函数概述概念函数声明情况下:要returin,没有return在函数执行完后返回undefined函数构造情况下:没有return返回this
不同的调用方法直接调用:foo();对象方法:o.method();构造器:new Foo();call/apply/bind:func.call(o);
函数声明与表达式声明与表达式的对比函数声明
function add (a, b) {
    a">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 函数相关知识点(函数、this、闭包、作用域)">
<meta property="og:url" content="http://ringcrl.com/2016-04/js-function/index.html">
<meta property="og:site_name" content="RingTalk">
<meta property="og:description" content="函数概述概念函数声明情况下:要returin,没有return在函数执行完后返回undefined函数构造情况下:没有return返回this
不同的调用方法直接调用:foo();对象方法:o.method();构造器:new Foo();call/apply/bind:func.call(o);
函数声明与表达式声明与表达式的对比函数声明
function add (a, b) {
    a">
<meta property="og:updated_time" content="2016-04-25T05:55:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript 函数相关知识点(函数、this、闭包、作用域)">
<meta name="twitter:description" content="函数概述概念函数声明情况下:要returin,没有return在函数执行完后返回undefined函数构造情况下:没有return返回this
不同的调用方法直接调用:foo();对象方法:o.method();构造器:new Foo();call/apply/bind:func.call(o);
函数声明与表达式声明与表达式的对比函数声明
function add (a, b) {
    a">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> JavaScript 函数相关知识点(函数、this、闭包、作用域) | RingTalk </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7c95bb71fd7c5dd5024a13675c205ea2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">RingTalk</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">最朴实的生活，最遥远的梦想。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'qp8_7pbfcjzMmTzmmaqF','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JavaScript 函数相关知识点(函数、this、闭包、作用域)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-24T00:00:00+08:00" content="2016-04-24">
              2016-04-24
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016-04/js-function/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016-04/js-function/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="函数概述"><a href="#函数概述" class="headerlink" title="函数概述"></a>函数概述</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>函数声明情况下:<br>要returin,没有return在函数执行完后返回undefined<br>函数构造情况下:<br>没有return返回this</p>
<h3 id="不同的调用方法"><a href="#不同的调用方法" class="headerlink" title="不同的调用方法"></a>不同的调用方法</h3><p>直接调用:foo();<br>对象方法:o.method();<br>构造器:new Foo();<br>call/apply/bind:func.call(o);</p>
<h2 id="函数声明与表达式"><a href="#函数声明与表达式" class="headerlink" title="函数声明与表达式"></a>函数声明与表达式</h2><h3 id="声明与表达式的对比"><a href="#声明与表达式的对比" class="headerlink" title="声明与表达式的对比"></a>声明与表达式的对比</h3><p>函数声明</p>
<pre><code>function add (a, b) {
    a = +a; 
    b = +b;
    if (isNaN(a) || isNaN(b)) {
        return; 
    }
    return a + b;
}
</code></pre><p> 函数表达式</p>
<p> // function variable<br>    var add = function (a, b) {<br>        // do sth<br>    };<br> // IEF(Immediately Executed Function)<br>    (function() {<br>         // do sth<br>    })();<br> // first-class function<br>     return function() {<br>         // do sth<br>    };<br> // NFE (Named Function Expression)<br>    var add = function foo (a, b) {<br>        // do sth<br>    };</p>
<h3 id="比一比"><a href="#比一比" class="headerlink" title="比一比"></a>比一比</h3><table>
<thead>
<tr>
<th></th>
<th>函数声明</th>
<th>函数表达式</th>
<th>函数构造器</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>允许匿名</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>立即调用</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>在定义该函数的的作用域通过函数名访问</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>没有函数名</td>
<td></td>
<td></td>
<td>√</td>
</tr>
</tbody>
</table>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="全局this-浏览器"><a href="#全局this-浏览器" class="headerlink" title="全局this(浏览器)"></a>全局this(浏览器)</h3><pre><code>console.log(this.document === document); // true

console.log(this === window); // true

this.a = 37;
console.log(window.a); // 37
</code></pre><h3 id="函数声明里的this-浏览器"><a href="#函数声明里的this-浏览器" class="headerlink" title="函数声明里的this(浏览器)"></a>函数声明里的this(浏览器)</h3><pre><code>function f1(){
    return this;
} 
f1() === window; // true, global object
</code></pre><h3 id="对象方法的函数this"><a href="#对象方法的函数this" class="headerlink" title="对象方法的函数this"></a>对象方法的函数this</h3><p>方法一(对象内函数):  </p>
<pre><code>var o = {
    prop: 37,
    f: function() {
        return this.prop;
    } 
};

console.log(o.f()); // logs 37
</code></pre><p>方法二(将函数作为对象方法调用):</p>
<pre><code>var o = {prop: 37};

function independent() {
return this.prop; 
} 

o.f = independent;

console.log(o.f()); // logs 37
</code></pre><h3 id="对象原型链上的this"><a href="#对象原型链上的this" class="headerlink" title="对象原型链上的this"></a>对象原型链上的this</h3><pre><code>var o = {f:function(){ return this.a + this.b; }};
var p = Object.create(o); 
p.a = 1; 
p.b = 4; 
console.log(p.f()); // 5
</code></pre><h3 id="构造器中的this"><a href="#构造器中的this" class="headerlink" title="构造器中的this"></a>构造器中的this</h3><pre><code>function MyClass(){
this.a = 37; 
} 

var o = new MyClass();
console.log(o.a); // 37 

function C2(){
this.a = 37;
return {a : 38};
} 

o = new C2();
console.log(o.a); // 38
</code></pre><h3 id="call-apply中的this"><a href="#call-apply中的this" class="headerlink" title="call/apply中的this"></a>call/apply中的this</h3><p>function add(c, d){<br>return this.a + this.b + c + d;<br>} </p>
<p>var o = {a:1, b:3};</p>
<p>add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</p>
<p>add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 </p>
<p>function bar() {<br>console.log(Object.prototype.toString.call(this));<br>} </p>
<p>bar.call(7); // “[object Number]”</p>
<h3 id="bind方法的this"><a href="#bind方法的this" class="headerlink" title="bind方法的this"></a>bind方法的this</h3><pre><code>function f(){
return this.a;
} 

var g = f.bind({a : &quot;test&quot;});
console.log(g()); // test

var o = {a : 37, f : f, g : g};
console.log(o.f(), o.g()); // 37, test
</code></pre><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><h3 id="函数属性与arguments"><a href="#函数属性与arguments" class="headerlink" title="函数属性与arguments"></a>函数属性与arguments</h3><pre><code>function foo(x, y, z) {
    ‘use strict’;
    arguments.length; // 2
    arguments[0]; // 1 
    arguments[0] = 10;
    x; // change to 10; 

    arguments[2] = 100;
    z; // still undefined !!!
    arguments.callee === foo; // true
} 

foo(1, 2);
foo.length; // 3
foo.name; // &quot;foo&quot;
</code></pre><p>foo.name-函数名<br>foo.length-形参个数<br>arguments.length-实参个数</p>
<h3 id="apply-call方法"><a href="#apply-call方法" class="headerlink" title="apply/call方法"></a>apply/call方法</h3><pre><code>function foo(x, y) {
console.log(x, y, this);
} 
foo.call(100, 1, 2); // 1, 2, Number(100)
foo.apply(true, [3, 4]); // 3, 4, Boolean(true)
foo.apply(null); // undefined, undefined, window
foo.apply(undefined); // undefined, undefined, window
</code></pre><h3 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h3><p>bind方法实现两个功能,一个是改变函数里面的this指向,一个是科里化(即把函数拆成不同的子函数,先设定一定的参数,后面调用的时候只需要补充剩下的参数就可以了)</p>
<pre><code>this.x = 9;  
var module = {
    x: 81,
    getX: function() { return this.x; }
};

module.getX(); // 81

var getX = module.getX; 
getX(); // 9 

var boundGetX = getX.bind(module);
boundGetX(); // 81
</code></pre><h4 id="bind与currying"><a href="#bind与currying" class="headerlink" title="bind与currying"></a>bind与currying</h4><p>概述:</p>
<pre><code>function add(a, b, c) {
return a + b + c; 
} 

var func = add.bind(undefined, 100);
func(1, 2); // 103 

var func2 = func.bind(undefined, 200);
func2(10); // 310
</code></pre><p>应用实例:</p>
<pre><code>function getConfig(colors, size, otherOptions) {
console.log(colors, size, otherOptions); 
} 

var defaultConfig = getConfig.bind(null, &quot;#CC0000&quot;, &quot;1024 * 768&quot;);

defaultConfig(&quot;123&quot;); // #CC0000 1024 * 768 123
defaultConfig(&quot;456&quot;); // #CC0000 1024 * 768 456
</code></pre><h4 id="bind与new"><a href="#bind与new" class="headerlink" title="bind与new"></a>bind与new</h4><p>用new会无视bind,还是指向函数中的this</p>
<pre><code>function foo() {
this.b = 100;
return this.a;
} 

var func = foo.bind({a:1}); 

func(); // 1
new func(); // {b : 100}
</code></pre><h2 id="理解闭包"><a href="#理解闭包" class="headerlink" title="理解闭包"></a>理解闭包</h2><h3 id="学习闭包"><a href="#学习闭包" class="headerlink" title="学习闭包"></a>学习闭包</h3><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<pre><code>　　var n=999;
　　function f1(){
　　　　alert(n);
　　}
　　f1(); // 999
</code></pre><p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<pre><code>　　function f1(){
　　　　var n=999;
　　}
　　alert(n); // error
</code></pre><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>
<pre><code>　　function f1(){
　　　　n=999;
　　}
　　f1();
　　alert(n); // 999
</code></pre><h4 id="如何从外部读取局部变量"><a href="#如何从外部读取局部变量" class="headerlink" title="如何从外部读取局部变量?"></a>如何从外部读取局部变量?</h4><p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
<pre><code>　　function f1(){
　　　　var n=999;
　　　　function f2(){
　　　　　　alert(n); // 999
　　　　}
　　}
</code></pre><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<pre><code>　　function f1(){
　　　　var n=999;
　　　　function f2(){
　　　　　　alert(n); 
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
</code></pre><h4 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h4><p>上一节代码中的f2函数，就是闭包。</p>
<p>各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h4 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h4><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>怎么来理解这句话呢？请看下面的代码。</p>
<pre><code>　　function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
</code></pre><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h4 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h4><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。</p>
<p>代码片段一:</p>
<pre><code>　　var name = &quot;The Window&quot;;
　　var object = {
　　　　name : &quot;My Object&quot;,
　　　　getNameFunc : function(){
　　　　　　return function(){
　　　　　　　　return this.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());
</code></pre><p>代码片段二:</p>
<pre><code>　　var name = &quot;The Window&quot;;
　　var object = {
　　　　name : &quot;My Object&quot;,
　　　　getNameFunc : function(){
　　　　　　var that = this;
　　　　　　return function(){
　　　　　　　　return that.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());
</code></pre><p>以上两个代码片段的结果分别是:<br>“The Window”和”My Object”</p>
<p>(代码一)先创建了一个全局变量名 name,又创建了一个包含 name 属性的对象.这个对象还包含一个方法—getNameFunc(),它返回一个匿名函数,而匿名函数又返回 this.name.由于 getNameFunc()返回一个函数,因此调用 object.getNameFunc()()会立即调用它返回的函数,结果就是返回一个字符串.然而这个例子返回的字符串是”The Window”,即全局 name 变量的值.为什么匿名函数没有取得其包括作用域(或外部作用域)的 this 对象呢?</p>
<p>每个函数在被调用时都会自动取得两个特殊变量: this 和 arguments.内部函数在搜索这两个变量时,只会搜索到其活动变量为止,因此永远不可能直接访问外部函数的这两个变量.不过把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里,就可以让闭包访问该对象了.(代码二)</p>
<p>在定义匿名函数之前,我们把this对象赋值给了一个名叫 that 的变量.而在定义闭包之后,闭包也可以访问这个变量,因此它是我们在包含函数中特意声明的一个变量.即时在函数返回后,that 也依然引用着 object,所以调用object.getNameFunc()()就返回了”My Object”</p>
<h3 id="闭包的使用与例子"><a href="#闭包的使用与例子" class="headerlink" title="闭包的使用与例子"></a>闭包的使用与例子</h3><h4 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h4><p>例子1:</p>
<pre><code>function outer() {
var localVal = 30;
return localVal; 
} 

outer(); // 30
</code></pre><p>例子2:</p>
<pre><code>function outer() {
var localVal = 30;
return function() {
return localVal;
} 
} 

var func = outer();
func(); // 30
</code></pre><h4 id="闭包的应用实例"><a href="#闭包的应用实例" class="headerlink" title="闭包的应用实例"></a>闭包的应用实例</h4><p>实例1:</p>
<pre><code>!function() {
var localData = &quot;localData here&quot;;
document.addEventListener(&apos;click&apos;,
function(){
console.log(localData); 
    }); 
}();
</code></pre><p>实例2:</p>
<pre><code>!function() {
var localData = &quot;localData here&quot;;
var url = &quot;http://www.baidu.com/&quot;;
$.ajax({ 
        url : url,
        success : function() {
        // do sth...
        console.log(localData); 
        } 
    }); 
}();
</code></pre><h3 id="闭包-封装"><a href="#闭包-封装" class="headerlink" title="闭包-封装"></a>闭包-封装</h3><pre><code>(function() {
var _userId = 23492;
var _typeId = &apos;item&apos;;
var export = {};

function converter(userId) {
return +userId; 
} 
export.getUserId = function() {
return converter(_userId);
} 
export.getTypeId = function() {
return _typeId; 
}
window.export = export; 
}());

export.getUserId(); // 23492
export.getTypeId();  // item 

export._userId;    // undefined
export._typeId;    // undefined
export.converter; // undefined 
</code></pre><h3 id="闭包小结"><a href="#闭包小结" class="headerlink" title="闭包小结"></a>闭包小结</h3><p>优点:灵活和方便、对函数内的变量进行封装,在export给外部使用<br>缺点:空间浪费、内存泄露、性能消耗</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域有三种:全局、函数、eval<br>JavaScript中没有块级作用域,所以在for()里面定义的var也是全局作用域.</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>理解例子:</p>
<pre><code>function outer2() { 
    var local2 = 1;
    function outer1() {
    var local1 = 1;
    // visit local1, local2 or global3
    } 
    outer1(); 
}
var global3 = 1;
outer2(); 

function outer() { 
    var i = 1;
    var func = new Function(&quot;console.log(typeof i);&quot;);
    func();  // undefined} 
outer();
</code></pre><h3 id="利用函数作用域封装"><a href="#利用函数作用域封装" class="headerlink" title="利用函数作用域封装"></a>利用函数作用域封装</h3><p>!/+function{}()和(function(){})()是一样的</p>
<pre><code>(function() {
      // do sth here
      var a, b; 
})(); 

!function() {
// do sth here
var a, b; 
}();
</code></pre><h2 id="ES3执行上下文"><a href="#ES3执行上下文" class="headerlink" title="ES3执行上下文"></a>ES3执行上下文</h2><p>理解这个例子:</p>
<pre><code>alert(x); //function                

var x = 10;
alert(x);  // 10
x = 20; 

function x() {}
alert(x);   // 20 

if (true) {
var a = 1;
} else {
var b = true;
} 

alert(a);   // 1
alert(b);   // undefined
</code></pre>
      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag">#JavaScript</a>
          
            <a href="/tags/函数/" rel="tag">#函数</a>
          
            <a href="/tags/this/" rel="tag">#this</a>
          
            <a href="/tags/arguments/" rel="tag">#arguments</a>
          
            <a href="/tags/闭包/" rel="tag">#闭包</a>
          
            <a href="/tags/作用域/" rel="tag">#作用域</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016-04/js-object/" rel="next" title="JavaScript 对象介绍与操作方法">
                <i class="fa fa-chevron-left"></i> JavaScript 对象介绍与操作方法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016-04/programme/" rel="prev" title="JavaScript 50道经典编程题">
                JavaScript 50道经典编程题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016-04/js-function/"
           data-title="JavaScript 函数相关知识点(函数、this、闭包、作用域)" data-url="http://ringcrl.com/2016-04/js-function/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/RingTalk.jpg"
               alt="Chenng" />
          <p class="site-author-name" itemprop="name">Chenng</p>
          <p class="site-description motion-element" itemprop="description">前端手艺人</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ringcrl" target="_blank" title="GitHub">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/ringcrl" target="_blank" title="Weibo">
                  
                    <i class="fa fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数概述"><span class="nav-number">1.</span> <span class="nav-text">函数概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同的调用方法"><span class="nav-number">1.2.</span> <span class="nav-text">不同的调用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数声明与表达式"><span class="nav-number">2.</span> <span class="nav-text">函数声明与表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明与表达式的对比"><span class="nav-number">2.1.</span> <span class="nav-text">声明与表达式的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比一比"><span class="nav-number">2.2.</span> <span class="nav-text">比一比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this"><span class="nav-number">3.</span> <span class="nav-text">this</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局this-浏览器"><span class="nav-number">3.1.</span> <span class="nav-text">全局this(浏览器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明里的this-浏览器"><span class="nav-number">3.2.</span> <span class="nav-text">函数声明里的this(浏览器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象方法的函数this"><span class="nav-number">3.3.</span> <span class="nav-text">对象方法的函数this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象原型链上的this"><span class="nav-number">3.4.</span> <span class="nav-text">对象原型链上的this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器中的this"><span class="nav-number">3.5.</span> <span class="nav-text">构造器中的this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#call-apply中的this"><span class="nav-number">3.6.</span> <span class="nav-text">call/apply中的this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind方法的this"><span class="nav-number">3.7.</span> <span class="nav-text">bind方法的this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arguments"><span class="nav-number">4.</span> <span class="nav-text">arguments</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数属性与arguments"><span class="nav-number">4.1.</span> <span class="nav-text">函数属性与arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply-call方法"><span class="nav-number">4.2.</span> <span class="nav-text">apply/call方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind方法"><span class="nav-number">4.3.</span> <span class="nav-text">bind方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bind与currying"><span class="nav-number">4.3.1.</span> <span class="nav-text">bind与currying</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind与new"><span class="nav-number">4.3.2.</span> <span class="nav-text">bind与new</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解闭包"><span class="nav-number">5.</span> <span class="nav-text">理解闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#学习闭包"><span class="nav-number">5.1.</span> <span class="nav-text">学习闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变量的作用域"><span class="nav-number">5.1.1.</span> <span class="nav-text">变量的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何从外部读取局部变量"><span class="nav-number">5.1.2.</span> <span class="nav-text">如何从外部读取局部变量?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包的概念"><span class="nav-number">5.1.3.</span> <span class="nav-text">闭包的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包的用途"><span class="nav-number">5.1.4.</span> <span class="nav-text">闭包的用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用闭包的注意点"><span class="nav-number">5.1.5.</span> <span class="nav-text">使用闭包的注意点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思考题"><span class="nav-number">5.1.6.</span> <span class="nav-text">思考题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包的使用与例子"><span class="nav-number">5.2.</span> <span class="nav-text">闭包的使用与例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包的使用"><span class="nav-number">5.2.1.</span> <span class="nav-text">闭包的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包的应用实例"><span class="nav-number">5.2.2.</span> <span class="nav-text">闭包的应用实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包-封装"><span class="nav-number">5.3.</span> <span class="nav-text">闭包-封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包小结"><span class="nav-number">5.4.</span> <span class="nav-text">闭包小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域"><span class="nav-number">6.</span> <span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域链"><span class="nav-number">6.1.</span> <span class="nav-text">作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用函数作用域封装"><span class="nav-number">6.2.</span> <span class="nav-text">利用函数作用域封装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES3执行上下文"><span class="nav-number">7.</span> <span class="nav-text">ES3执行上下文</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <a style="text-decoration:none;" href="https://github.com/ringcrl" target="_blank">GitHub</a>
<span>&</span>
<a style="text-decoration:none;" href="http://weibo.com/ringcrl" target="_blank">Weibo</a>

<div class="copyright" >
  
  &copy;
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenng</span>
</div>
        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ringtalk"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
